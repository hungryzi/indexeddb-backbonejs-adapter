// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

window.Driver = (function(_super) {

  __extends(Driver, _super);

  function Driver() {
    return Driver.__super__.constructor.apply(this, arguments);
  }

  Driver.prototype._track_transaction = function(transaction) {
    var removeIt,
      _this = this;
    this.transactions.push(transaction);
    removeIt = function() {
      var idx;
      idx = _this.transactions.indexOf(transaction);
      if (idx !== -1) {
        return _this.transactions.splice(idx);
      }
    };
    transaction.oncomplete = removeIt;
    transaction.onabort = removeIt;
    return transaction.onerror = removeIt;
  };

  Driver.prototype.execute = function(storeName, method, object, options) {
    this.logger("execute : " + method + " on " + storeName + " for " + object.id);
    switch (method) {
      case "create":
        return this.create(storeName, object, options);
      case "read":
        if (object.id || object.cid) {
          return this.read(storeName, object, options);
        } else {
          return this.query(storeName, object, options);
        }
        break;
      case "update":
        return this.update(storeName, object, options);
      case "delete":
        if (object.id || object.cid) {
          return this["delete"](storeName, object, options);
        } else {
          return this.clear(storeName, object, options);
        }
        break;
      default:
        return this.logger("Unknown method", method, "is called for", object);
    }
  };

  Driver.prototype.create = function(storeName, object, options) {
    var json, store, writeRequest, writeTransaction;
    writeTransaction = this.db.transaction([storeName], 'readwrite');
    store = writeTransaction.objectStore(storeName);
    json = object.toJSON();
    if (json.id === void 0) {
      json.id = guid();
    }
    if (json.id === null) {
      delete json.id;
    }
    if (!store.keyPath) {
      writeRequest = store.add(json, json.id);
    } else {
      writeRequest = store.add(json);
    }
    writeRequest.onerror = function(e) {
      return options.error(e);
    };
    return writeRequest.onsuccess = function(e) {
      return options.success(json);
    };
  };

  Driver.prototype.update = function(storeName, object, options) {
    var json, store, writeRequest, writeTransaction;
    writeTransaction = this.db.transaction([storeName], 'readwrite');
    store = writeTransaction.objectStore(storeName);
    json = object.toJSON();
    writeRequest;

    if (!json.id) {
      json.id = guid();
    }
    if (!store.keyPath) {
      writeRequest = store.put(json, json.id);
    } else {
      writeRequest = store.put(json);
    }
    writeRequest.onerror = function(e) {
      return options.error(e);
    };
    return writeRequest.onsuccess = function(e) {
      return options.success(json);
    };
  };

  Driver.prototype.read = function(storeName, object, options) {
    var getRequest, json, readTransaction, store;
    readTransaction = this.db.transaction([storeName], "readonly");
    this._track_transaction(readTransaction);
    store = readTransaction.objectStore(storeName);
    json = object.toJSON();
    getRequest = null;
    if (json.id) {
      getRequest = store.get(json.id);
    } else {
      _.each(store.indexNames, function(key, index) {
        index = store.index(key);
        if (json[index.keyPath] && !getRequest) {
          return getRequest = index.get(json[index.keyPath]);
        }
      });
    }
    if (getRequest) {
      getRequest.onsuccess = function(event) {
        if (event.target.result) {
          return options.success(event.target.result);
        } else {
          return options.error("Not Found");
        }
      };
      return getRequest.onerror = function() {
        return options.error("Not Found");
      };
    } else {
      return ptions.error("Not Found");
    }
  };

  Driver.prototype["delete"] = function(storeName, object, options) {
    var deleteRequest, deleteTransaction, json, store;
    deleteTransaction = this.db.transaction([storeName], 'readwrite');
    store = deleteTransaction.objectStore(storeName);
    json = object.toJSON();
    deleteRequest = store["delete"](json.id);
    deleteRequest.onsuccess = function(event) {
      return options.success(null);
    };
    return deleteRequest.onerror = function(event) {
      return options.error("Not Deleted");
    };
  };

  Driver.prototype.clear = function(storeName, object, options) {
    var deleteRequest, deleteTransaction, store;
    deleteTransaction = this.db.transaction([storeName], "readwrite");
    store = deleteTransaction.objectStore(storeName);
    deleteRequest = store.clear();
    deleteRequest.onsuccess = function(event) {
      return options.success(null);
    };
    return deleteRequest.onerror = function(event) {
      return options.error("Not Cleared");
    };
  };

  Driver.prototype.query = function(storeName, collection, options) {
    var bounds, elements, index, lower, processed, queryTransaction, readCursor, skipped, store, upper;
    elements = [];
    skipped = 0;
    processed = 0;
    queryTransaction = this.db.transaction([storeName], "readonly");
    readCursor = null;
    store = queryTransaction.objectStore(storeName);
    index = null;
    lower = null;
    upper = null;
    bounds = null;
    if (options.conditions) {
      _.each(store.indexNames, function(key) {
        if (!readCursor) {
          index = store.index(key);
          if (options.conditions[index.keyPath] instanceof Array) {
            lower = options.conditions[index.keyPath][0] > options.conditions[index.keyPath][1] ? options.conditions[index.keyPath][1] : options.conditions[index.keyPath][0];
            upper = options.conditions[index.keyPath][0] > options.conditions[index.keyPath][1] ? options.conditions[index.keyPath][0] : options.conditions[index.keyPath][1];
            bounds = IDBKeyRange.bound(lower, upper, true, true);
            if (options.conditions[index.keyPath][0] > options.conditions[index.keyPath][1]) {
              return readCursor = index.openCursor(bounds, window.IDBCursor.PREV || "prev");
            } else {
              return readCursor = index.openCursor(bounds, window.IDBCursor.NEXT || "next");
            }
          } else if (options.conditions[index.keyPath] !== void 0) {
            bounds = IDBKeyRange.only(options.conditions[index.keyPath]);
            return readCursor = index.openCursor(bounds);
          }
        }
      });
    } else {
      if (options.range) {
        lower = options.range[0] > options.range[1] ? options.range[1] : options.range[0];
        upper = options.range[0] > options.range[1] ? options.range[0] : options.range[1];
        bounds = IDBKeyRange.bound(lower, upper);
        if (options.range[0] > options.range[1]) {
          readCursor = store.openCursor(bounds, window.IDBCursor.PREV || "prev");
        } else {
          readCursor = store.openCursor(bounds, window.IDBCursor.NEXT || "next");
        }
      } else {
        readCursor = store.openCursor();
      }
    }
    if (typeof readCursor === "undefined" || !readCursor) {
      return options.error("No Cursor");
    } else {
      readCursor.onerror = function(e) {
        return options.error("readCursor error", e);
      };
      return readCursor.onsuccess = function(e) {
        var cursor, deleteRequest;
        cursor = e.target.result;
        if (!cursor) {
          if (options.addIndividually || options.clear) {
            return collection.trigger("reset");
          } else {
            return options.success(elements);
          }
        } else {
          if (options.limit && processed >= options.limit) {
            if (bounds && options.conditions[index.keyPath]) {
              return cursor["continue"](options.conditions[index.keyPath][1] + 1);
            } else {
              return cursor["continue"]();
            }
          } else if (options.offset && options.offset > skipped) {
            skipped++;
            return cursor["continue"]();
          } else {
            if (options.addIndividually) {
              collection.add(cursor.value);
            } else if (options.clear) {
              deleteRequest = store["delete"](cursor.value.id);
              deleteRequest.onsuccess = function(event) {
                return elements.push(cursor.value);
              };
              deleteRequest.onerror = function(event) {
                return elements.push(cursor.value);
              };
            } else {
              elements.push(cursor.value);
            }
            processed++;
            return cursor["continue"]();
          }
        }
      };
    }
  };

  return Driver;

})(window.Driver);
