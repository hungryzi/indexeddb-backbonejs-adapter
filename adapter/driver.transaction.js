// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

window.Driver = (function(_super) {

  __extends(Driver, _super);

  function Driver() {
    return Driver.__super__.constructor.apply(this, arguments);
  }

  Driver.prototype._track_transaction = function(transaction) {
    var removeIt,
      _this = this;
    this.transactions.push(transaction);
    removeIt = function() {
      var idx;
      idx = _this.transactions.indexOf(transaction);
      if (idx !== -1) {
        return _this.transactions.splice(idx);
      }
    };
    transaction.oncomplete = removeIt;
    transaction.onabort = removeIt;
    return transaction.onerror = removeIt;
  };

  Driver.prototype.execute = function(storeName, method, object, options) {
    var request, transaction;
    this.logger("execute : " + method + " on " + storeName + " for " + object.id);
    switch (method) {
      case "create":
        transaction = this.db.transaction([storeName], 'readwrite');
        request = new Driver.AddRequest(transaction, storeName, object.toJSON(), options);
        break;
      case "read":
        if (object.id || object.cid) {
          transaction = this.db.transaction([storeName], "readonly");
          request = new Driver.GetRequest(transaction, storeName, object.toJSON(), options);
        } else {
          this.query(storeName, object, options);
        }
        break;
      case "update":
        transaction = this.db.transaction([storeName], 'readwrite');
        request = new Driver.PutRequest(transaction, storeName, object.toJSON(), options);
        break;
      case "delete":
        transaction = this.db.transaction([storeName], 'readwrite');
        if (object.id || object.cid) {
          request = new Driver.DeleteRequest(transaction, storeName, object.toJSON(), options);
        } else {
          request = new Driver.ClearRequest(transaction, storeName, object.toJSON(), options);
        }
        break;
      default:
        this.logger("Unknown method", method, "is called for", object);
    }
    if (request) {
      return request.execute();
    }
  };

  Driver.prototype.query = function(storeName, collection, options) {
    var bounds, elements, index, lower, processed, queryTransaction, readCursor, skipped, store, upper;
    elements = [];
    skipped = 0;
    processed = 0;
    queryTransaction = this.db.transaction([storeName], "readonly");
    readCursor = null;
    store = queryTransaction.objectStore(storeName);
    index = null;
    lower = null;
    upper = null;
    bounds = null;
    if (options.conditions) {
      _.each(store.indexNames, function(key) {
        if (!readCursor) {
          index = store.index(key);
          if (options.conditions[index.keyPath] instanceof Array) {
            lower = options.conditions[index.keyPath][0] > options.conditions[index.keyPath][1] ? options.conditions[index.keyPath][1] : options.conditions[index.keyPath][0];
            upper = options.conditions[index.keyPath][0] > options.conditions[index.keyPath][1] ? options.conditions[index.keyPath][0] : options.conditions[index.keyPath][1];
            bounds = IDBKeyRange.bound(lower, upper, true, true);
            if (options.conditions[index.keyPath][0] > options.conditions[index.keyPath][1]) {
              return readCursor = index.openCursor(bounds, window.IDBCursor.PREV || "prev");
            } else {
              return readCursor = index.openCursor(bounds, window.IDBCursor.NEXT || "next");
            }
          } else if (options.conditions[index.keyPath] !== void 0) {
            bounds = IDBKeyRange.only(options.conditions[index.keyPath]);
            return readCursor = index.openCursor(bounds);
          }
        }
      });
    } else {
      if (options.range) {
        lower = options.range[0] > options.range[1] ? options.range[1] : options.range[0];
        upper = options.range[0] > options.range[1] ? options.range[0] : options.range[1];
        bounds = IDBKeyRange.bound(lower, upper);
        if (options.range[0] > options.range[1]) {
          readCursor = store.openCursor(bounds, window.IDBCursor.PREV || "prev");
        } else {
          readCursor = store.openCursor(bounds, window.IDBCursor.NEXT || "next");
        }
      } else {
        readCursor = store.openCursor();
      }
    }
    if (typeof readCursor === "undefined" || !readCursor) {
      return options.error("No Cursor");
    } else {
      readCursor.onerror = function(e) {
        return options.error("readCursor error", e);
      };
      return readCursor.onsuccess = function(e) {
        var cursor, deleteRequest;
        cursor = e.target.result;
        if (!cursor) {
          if (options.addIndividually || options.clear) {
            return collection.trigger("reset");
          } else {
            return options.success(elements);
          }
        } else {
          if (options.limit && processed >= options.limit) {
            if (bounds && options.conditions[index.keyPath]) {
              return cursor["continue"](options.conditions[index.keyPath][1] + 1);
            } else {
              return cursor["continue"]();
            }
          } else if (options.offset && options.offset > skipped) {
            skipped++;
            return cursor["continue"]();
          } else {
            if (options.addIndividually) {
              collection.add(cursor.value);
            } else if (options.clear) {
              deleteRequest = store["delete"](cursor.value.id);
              deleteRequest.onsuccess = function(event) {
                return elements.push(cursor.value);
              };
              deleteRequest.onerror = function(event) {
                return elements.push(cursor.value);
              };
            } else {
              elements.push(cursor.value);
            }
            processed++;
            return cursor["continue"]();
          }
        }
      };
    }
  };

  return Driver;

})(window.Driver);
